<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sp.app.farm.mapper.FarmSaleMapper">

<!-- 내농가 판매 조회 관련 쿼리-->

<!-- 상단 총 벌은 금액 -->
<select id="myFarmTotalEarning" parameterType="Long"  resultType="java.math.BigDecimal">
	SELECT NVL(SUM( NVL(s.supplyQuantity,0) / NULLIF(NVL(s.unitQuantity,1), 0) * NVL(s.unitPrice,0)), 0) AS totalEarning
	FROM supply s
	WHERE s.farmNum = #{farmNum}
    AND s.state = 5
    AND s.approvedDate IS NOT NULL
</select>

<!-- 품종별 리스트 -->
<select id="myFarmListByVariety" parameterType="map"
        resultType="com.sp.app.farm.model.MyFarmSale">
  SELECT
    v.varietyNum,
    v.varietyName,
    SUM(NVL(s.supplyQuantity, 0)) AS totalQty,
    NVL(SUM(
      NVL(s.supplyQuantity,0) / NULLIF(NVL(s.unitQuantity,1), 0) * NVL(s.unitPrice,0)
    ), 0) AS totalVarietyEarning
  FROM supply s
  JOIN variety v ON v.varietyNum = s.varietyNum
  <where>
    s.farmNum = #{farmNum}
    AND s.state = 5
    AND s.approvedDate IS NOT NULL
    <if test="productNumOnly != null and productNumOnly == 1">
      AND s.productNum IS NOT NULL
    </if>
    <if test="varietyNum != null and varietyNum &gt; 0">
      AND s.varietyNum = #{varietyNum}
    </if>

    <if test="kwd != null and kwd != ''">
      <choose>
        <when test="schType == 'varietyName'">
          AND LOWER(v.varietyName) LIKE '%' || LOWER(#{kwd}) || '%'
        </when>
        <when test="schType == 'coment'">
          AND LOWER(NVL(s.coment,'')) LIKE '%' || LOWER(#{kwd}) || '%'
        </when>
      </choose>
    </if>
  </where>
  GROUP BY v.varietyNum, v.varietyName
  ORDER BY totalVarietyEarning DESC, totalQty DESC
  OFFSET #{offset} ROWS FETCH FIRST #{size} ROWS ONLY
</select>

<select id="myFarmListByVarietyCount" parameterType="map" resultType="int">
  SELECT COUNT(*)
  FROM (
    SELECT v.varietyNum
    FROM supply s
    JOIN variety v ON v.varietyNum = s.varietyNum
    <where>
      s.farmNum = #{farmNum}
      AND s.state = 5
      AND s.approvedDate IS NOT NULL
      <if test="productNumOnly != null and productNumOnly == 1">
        AND s.productNum IS NOT NULL
      </if>
      <if test="varietyNum != null and varietyNum &gt; 0">
        AND s.varietyNum = #{varietyNum}
      </if>

      <if test="kwd != null and kwd != ''">
        <choose>
          <when test="schType == 'varietyName'">
            AND LOWER(v.varietyName) LIKE '%' || LOWER(#{kwd}) || '%'
          </when>
          <when test="schType == 'coment'">
            AND LOWER(NVL(s.coment,'')) LIKE '%' || LOWER(#{kwd}) || '%'
          </when>
        </choose>
      </if>
    </where>
    GROUP BY v.varietyNum
  )
</select>




<!-- 전체 총 판매량 : 월별 판매순위 TOP10 (결제완료 기준) -->
<select id="topMonthlySalesSeries"
        parameterType="map"
        resultType="com.sp.app.farm.model.MonthlySalesRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), -11) AS start_dt,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'),  1)  AS end_dt
    FROM dual
  ),
  base AS (
    SELECT
      TRUNC(po.orderDate, 'MM') AS ym,
      od.productNum,
      SUM(NVL(od.qty,0)) AS totalQty
    FROM orderDetail od
    JOIN productOrder po ON po.orderNum = od.orderNum
    CROSS JOIN M
    WHERE po.orderDate &gt;= M.start_dt
      AND po.orderDate &lt;  M.end_dt
      <choose>
        <when test="paidStates != null and paidStates.size() &gt; 0">
          AND po.orderState IN
          <foreach collection="paidStates" item="st" open="(" close=")" separator=",">
            #{st}
          </foreach>
        </when>
        <otherwise>
          AND EXISTS (SELECT 1 FROM payDetail pd WHERE pd.orderNum = po.orderNum)
          AND NOT EXISTS (
            SELECT 1 FROM payCancel pc
            WHERE pc.orderNum = po.orderNum
              AND NVL(pc.cancelAmount,0) &gt;= NVL(po.totalMoney,0)
          )
        </otherwise>
      </choose>
    GROUP BY TRUNC(po.orderDate,'MM'), od.productNum
  ),
  ranked AS (
    SELECT
      TO_CHAR(b.ym, 'YYYY-MM') AS label,
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      b.totalQty,
      ROW_NUMBER() OVER (
        PARTITION BY b.ym
        ORDER BY b.totalQty DESC
      ) AS rn
    FROM base b
    JOIN Product p ON p.productNum = b.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
  )
  SELECT
    productNum,
    productName,
    varietyNum,
    varietyName,
    totalQty,
    rn,
    label
  FROM ranked
  WHERE rn &lt;= 10
  ORDER BY label, rn
</select>

<!-- 전체 총 인기 순위-->
<select id="topMonthlyRatingSeries"
        parameterType="map"
        resultType="com.sp.app.farm.model.MonthlyRatingRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), -11) AS start_dt,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'),  1)  AS end_dt
    FROM dual
  ),
  base AS (
    SELECT
      TRUNC(r.reviewDate, 'MM') AS ym,
      r.productNum,
      ROUND(AVG(r.star), 2) AS avgStar,
      COUNT(*) AS reviewCnt
    FROM productReview r
    CROSS JOIN M
    WHERE r.reviewDate &gt;= M.start_dt
      AND r.reviewDate &lt;  M.end_dt
    GROUP BY TRUNC(r.reviewDate,'MM'), r.productNum
    HAVING COUNT(*) &gt;= NVL(#{minReviews}, 1)
  ),
  ranked AS (
    SELECT
      TO_CHAR(b.ym, 'YYYY-MM') AS label,
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      b.avgStar,
      b.reviewCnt,
      ROW_NUMBER() OVER (
        PARTITION BY b.ym
        ORDER BY b.avgStar DESC, b.reviewCnt DESC
      ) AS rn
    FROM base b
    JOIN Product p ON p.productNum = b.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
  )
  SELECT
    productNum,
    productName,
    varietyNum,
    varietyName,
    avgStar,
    reviewCnt,
    rn,
    label
  FROM ranked
  WHERE rn &lt;= 10
  ORDER BY label, rn
</select>



<!-- 그냥 추가로 넣은거 -->
<select id="topMonthlySales" parameterType="map"
        resultType="com.sp.app.farm.model.MonthlySalesRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM') AS start_dt,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), 1) AS end_dt
    FROM dual
  ),
  base AS (
    SELECT od.productNum, SUM(NVL(od.qty,0)) AS totalQty
    FROM orderDetail od
    JOIN productOrder po ON po.orderNum = od.orderNum
    CROSS JOIN M
    WHERE po.orderDate &gt;= M.start_dt
      AND po.orderDate &lt;  M.end_dt
      <choose>
        <when test="paidStates != null and paidStates.size() &gt; 0">
          AND po.orderState IN
          <foreach collection="paidStates" item="st" open="(" close=")" separator=",">
            #{st}
          </foreach>
        </when>
        <otherwise>
          AND EXISTS (SELECT 1 FROM payDetail pd WHERE pd.orderNum = po.orderNum)
          AND NOT EXISTS (
            SELECT 1 FROM payCancel pc
            WHERE pc.orderNum = po.orderNum
              AND NVL(pc.cancelAmount,0) &gt;= NVL(po.totalMoney,0)
          )
        </otherwise>
      </choose>
    GROUP BY od.productNum
  )
  SELECT *
  FROM (
    SELECT
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      b.totalQty,
      ROW_NUMBER() OVER (ORDER BY b.totalQty DESC) AS rn,
      TO_CHAR((SELECT start_dt FROM M), 'YYYY-MM') AS label
    FROM base b
    JOIN Product p ON p.productNum = b.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
  )
  WHERE rn &lt;= 10
  ORDER BY rn
</select>

<select id="topMonthlyRating" parameterType="map"
        resultType="com.sp.app.farm.model.MonthlyRatingRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM') AS start_dt,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), 1) AS end_dt
    FROM dual
  )
  SELECT *
  FROM (
    SELECT
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      ROUND(AVG(r.star),2) AS avgStar,
      COUNT(*) AS reviewCnt,
      ROW_NUMBER() OVER (ORDER BY ROUND(AVG(r.star),2) DESC, COUNT(*) DESC) AS rn,
      TO_CHAR((SELECT start_dt FROM M), 'YYYY-MM') AS label
    FROM productReview r
    CROSS JOIN M
    JOIN Product p ON p.productNum = r.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
    WHERE r.reviewDate &gt;= M.start_dt
      AND r.reviewDate &lt;  M.end_dt
    GROUP BY p.productNum, p.productName, v.varietyNum, v.varietyName
    HAVING COUNT(*) &gt;= NVL(#{minReviews}, 1)
  )
  WHERE rn &lt;= 10
  ORDER BY rn
</select>

<select id="topMonthlySalesThisVsLast" parameterType="map"
        resultType="com.sp.app.farm.model.MonthlySalesRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM') AS this_start,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), 1) AS this_end,
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}-1), 'MM') AS last_start,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}-1), 'MM'), 1) AS last_end
    FROM dual
  ),
  base AS (
    SELECT
      CASE
        WHEN po.orderDate &gt;= (SELECT this_start FROM M) AND po.orderDate &lt; (SELECT this_end FROM M) THEN 'THIS'
        WHEN po.orderDate &gt;= (SELECT last_start FROM M) AND po.orderDate &lt; (SELECT last_end FROM M) THEN 'LAST'
      END AS label,
      od.productNum,
      SUM(NVL(od.qty,0)) AS totalQty
    FROM orderDetail od
    JOIN productOrder po ON po.orderNum = od.orderNum
    WHERE (
        (po.orderDate &gt;= (SELECT last_start FROM M) AND po.orderDate &lt; (SELECT last_end FROM M))
        OR
        (po.orderDate &gt;= (SELECT this_start FROM M) AND po.orderDate &lt; (SELECT this_end FROM M))
      )
      <choose>
        <when test="paidStates != null and paidStates.size() &gt; 0">
          AND po.orderState IN
          <foreach collection="paidStates" item="st" open="(" close=")" separator=",">
            #{st}
          </foreach>
        </when>
        <otherwise>
          AND EXISTS (SELECT 1 FROM payDetail pd WHERE pd.orderNum = po.orderNum)
          AND NOT EXISTS (
            SELECT 1 FROM payCancel pc
            WHERE pc.orderNum = po.orderNum
              AND NVL(pc.cancelAmount,0) &gt;= NVL(po.totalMoney,0)
          )
        </otherwise>
      </choose>
    GROUP BY
      CASE
        WHEN po.orderDate &gt;= (SELECT this_start FROM M) AND po.orderDate &lt; (SELECT this_end FROM M) THEN 'THIS'
        WHEN po.orderDate &gt;= (SELECT last_start FROM M) AND po.orderDate &lt; (SELECT last_end FROM M) THEN 'LAST'
      END,
      od.productNum
  )
  SELECT *
  FROM (
    SELECT
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      b.totalQty,
      ROW_NUMBER() OVER (PARTITION BY b.label ORDER BY b.totalQty DESC) AS rn,
      b.label
    FROM base b
    JOIN Product p ON p.productNum = b.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
  )
  WHERE rn &lt;= 10
  ORDER BY label, rn
</select>

<select id="topMonthlyRatingThisVsLast" parameterType="map"
        resultType="com.sp.app.farm.model.MonthlyRatingRank">
  WITH product_variety AS (
    SELECT productNum, varietyNum FROM (
      SELECT s.productNum, s.varietyNum,
             ROW_NUMBER() OVER (
               PARTITION BY s.productNum
               ORDER BY NVL(s.approvedDate, s.harvestDate) DESC, s.supplyNum DESC
             ) rn
      FROM supply s
    ) WHERE rn = 1
  ),
  M AS (
    SELECT
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM') AS this_start,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}), 'MM'), 1) AS this_end,
      TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}-1), 'MM') AS last_start,
      ADD_MONTHS(TRUNC(ADD_MONTHS(SYSDATE, #{m_offset}-1), 'MM'), 1) AS last_end
    FROM dual
  ),
  base AS (
    SELECT
      CASE
        WHEN r.reviewDate &gt;= (SELECT this_start FROM M) AND r.reviewDate &lt; (SELECT this_end FROM M) THEN 'THIS'
        WHEN r.reviewDate &gt;= (SELECT last_start FROM M) AND r.reviewDate &lt; (SELECT last_end FROM M) THEN 'LAST'
      END AS label,
      r.productNum,
      ROUND(AVG(r.star),2) AS avgStar,
      COUNT(*) AS reviewCnt
    FROM productReview r
    WHERE (
      (r.reviewDate &gt;= (SELECT last_start FROM M) AND r.reviewDate &lt; (SELECT last_end FROM M))
      OR
      (r.reviewDate &gt;= (SELECT this_start FROM M) AND r.reviewDate &lt; (SELECT this_end FROM M))
    )
    GROUP BY
      CASE
        WHEN r.reviewDate &gt;= (SELECT this_start FROM M) AND r.reviewDate &lt; (SELECT this_end FROM M) THEN 'THIS'
        WHEN r.reviewDate &gt;= (SELECT last_start FROM M) AND r.reviewDate &lt; (SELECT last_end FROM M) THEN 'LAST'
      END,
      r.productNum
    HAVING COUNT(*) &gt;= NVL(#{minReviews}, 1)
  )
  SELECT *
  FROM (
    SELECT
      p.productNum,
      p.productName,
      v.varietyNum,
      v.varietyName,
      b.avgStar,
      b.reviewCnt,
      ROW_NUMBER() OVER (PARTITION BY b.label ORDER BY b.avgStar DESC, b.reviewCnt DESC) AS rn,
      b.label
    FROM base b
    JOIN Product p ON p.productNum = b.productNum
    LEFT JOIN product_variety pv ON pv.productNum = p.productNum
    LEFT JOIN variety v         ON v.varietyNum  = pv.varietyNum
  )
  WHERE rn &lt;= 10
  ORDER BY label, rn
</select>


</mapper>